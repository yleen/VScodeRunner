# 乐天派
栈和堆的区别  堆中有值类型吗  怎么存储的

hash表的实现方法  当key为对象时怎么处理

岛屿问题 prim

线性代数：点到直线的距离（向量积）

tcp 中的 流量控制 与 拥塞控制

垃圾回收gc机制

# 疯狂游戏

一个向量上的两个不同的向量 求法向量 （叉乘）

所有的矩阵都有逆矩阵吗 （只有方阵才有逆矩阵 充要条件是行列式不为0）

矩阵乘法

离散的点连成一条光滑的曲线 （拟合 差值）

广度优先和深度优先结果的区别， 如何优化。

一个有序数组将其中一个变得不有序 使用什么排序算法来回归有序 （冒泡）

A* 算法

# 后端


nginx

## 多线程多进程 协程 并发 并行 高并发
**进程**

进程，就是这种“程序切换”的第一种方式。

定义

进程，是执行中的计算机程序。也就是说，每个代码在执行的时候，首先本身即是一个进程。

一个进程具有：就绪，运行，中断，僵死，结束等状态（不同操作系统不一样）。

使用

用户编写代码(代码本身是以进程运行的)
启动程序，进入进程“就绪”状态
操作系统调度资源，做“程序切换”，使得进程进入“运行”状态
结束/中断

程序执行完，则进入“结束”状态
程序未执行完，但操作系统达到“程序切换”的要求，进入“中断”状态，等待下次被调度后执行


特性

每个程序，本身首先是一个进程
运行中每个进程都拥有自己的地址空间、内存、数据栈及其它资源。
操作系统本身自动管理着所有的进程(不需要用户代码干涉)，并为这些进程合理分配可以执行时间。
进程可以通过派生新的进程来执行其它任务，不过每个进程还是都拥有自己的内存和数据栈等。
进程间可以通讯(发消息和数据)，采用 进程间通信(IPC) 方式。
说明

多个进程可以在不同的 CPU 上运行，互不干扰
同一个CPU上，可以运行多个进程，由操作系统来自动分配时间片
由于进程间资源不能共享，需要进程间通信，来发送数据，接受消息等
多进程，也称为“并行”。
**线程**

线程，也是“程序切换”的一种方式。

定义

线程，是在进程中执行的代码。

一个进程下可以运行多个线程，这些线程之间共享主进程内申请的操作系统资源。

在一个进程中启动多个线程的时候，每个线程按照顺序执行。现在的操作系统中，也支持线程抢占，也就是说其它等待运行的线程，可以通过优先级，信号等方式，将运行的线程挂起，自己先运行。

使用

用户编写包含线程的程序(每个程序本身都是一个进程)
操作系统“程序切换”进入当前进程
当前进程包含了线程，则启动线程
多个线程，则按照顺序执行，除非抢占
特性

线程，必须在一个存在的进程中启动运行
线程使用进程获得的系统资源，不会像进程那样需要申请CPU等资源
线程无法给予公平执行时间，它可以被其他线程抢占，而进程按照操作系统的设定分配执行时间
每个进程中，都可以启动很多个线程
说明

多线程，也被称为”并发“执行。

**协程**

协程，也是”程序切换“的一种。

这里提一个特殊的“线程”，也就是协程的概念。

定义

简单说，协程也是线程，只是协程的调度并不是由操作系统调度，而是自己”协同调度“。也就是”协程是不通过操作系统调度的线程“。当然，实际要比这更复杂一些，本课程不研究协程技术，对于这个很有挑战的技术，在我们完全掌握了进程线程后，自然会理解问题渊源。

协程，又称微线程。

说明

协程的主要特色是：

协程间是协同调度的，这使得并发量数万以上的时候，协程的性能是远远高于线程。
注意这里也是“并发”，不是“并行”。

**并发**
并发（Concurrency）
是由【P进程】引申出来的抽象概念。上面说到了你可以假设自己一个人按照一定的步骤来铺路，一个人从头干到尾，这是一个“串行”的【P进程】。但你也可以假设有2个人铺路。比如你可以按照长度分两半，一人铺500m * 50m；也可以按宽度划分，一人铺1000m * 25m；你还可以说让一个人负责铺全部路面的前5个步骤，另外一个人负责铺路面的余下5个步骤。然后你可以进一步想，假如不是雇2个人，而是雇20个人概如何分工呢？你可以混搭按长度，宽度，步骤等各种方式进行拆分。你甚至可以考虑这20个人不是完全一样的，有的能力强，有的能力弱，可以适当的调整工作量的比例等等。不管怎样拆，都意味着你得到了【并发】的【P进程】。换成说人话就是，你有一套方案，可以让多个人一起把事情做的更高效。注意是“可以“让事情更高效，而不是“必然“让事情更高效。是不是更高效要看到底是怎么执行的，后边会讲。举个写代码的例子，你有一个很长很长的数组，目标是把每一个数都*2。一个并发的做法就是把数组拆为很多个小段，然后每个小段的元素依次自己*2。这样的程序写出来就是一个【并发】的【程序】。这个程序如果运行起来就是【并发】的【OS进程】。这时就会出现一个问题，当你想把一个【并发】的【P进程】写成程序时，你怎么用编程语言告诉操作系统你的程序的一些步骤是【并发】的。更确切地说，你需要一个写法（可能是语法，也可能是函数库）表达：几个任务是【并发】的【并发】的任务之间是怎么交互协作的为了解决这两个问题，人们总结了一些方法，并将其称为“并发模型”。比如：Fork & Join模型（大任务拆解为小任务并发的跑，结果再拼起来）Actor模型（干活的步骤之间直接发消息）CSP模型（干活的步骤之间订阅通话的频道来协作）线程&锁模型（干活的人共享一个小本本，用来协作。注意小本本不能改乱套了，所以得加锁）…… 以Java中的线程为例，大家想表达【并发】就启动新的Thread（或者某种等价操作，如利用线程池）；想让Thread之间交互，就要依靠共享内容。但是【并发】的Thread如果同时修改同一份数据就有可能出错（被称为竞争问题），为了解决这个问题就要引入锁（Lock，或者一些高级的同步工具，如CountdownLatch，Semaphore）。
如果你用go，那么表达并发的工具就是goroutine，goroutine之间协作要用channel。（当然也可以用Sync包加锁，不展开）。

**并行**
现在我们已经有了一个【并发】的想法，然后进入执行层面。回到上面铺路的例子，你虽然假设有20个人可以一起干活。但你不一定真的能雇得到20个人。假如说你实际上最终只雇到1个人。但你有一个为20个人一起干活设计的方法。能不能用呢？当然能，只要让这个人先干第1人份的活，再干第2人份的……但如果你真的雇了10个人，就可以很容易的让第1个人干第1人份和第2人份的活，第2个人干第3和第4人份的活…… 而这10个人同时在工地上干活，就是【并行】（Parallelism）。在软件系统中，【程序】是否能【并行】运行，要看物理上有多少个CPU核心可以同时干活（或者再扩展一下，有多少台可用的物理主机）。比如你写了个Java程序，同时启动了4个线程，但CPU只有单核，那么同一时刻只有一个线程在运行。如果有4个CPU核心，那么可以做到4个线程完全【并行】运行。如果有2个核心，那么就处于一种中间态。比如你可以用“并发度=4“，”并行度=2“形容这种情况。

## redis rabbitmq 模式

es分词

