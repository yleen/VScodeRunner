# Go和C++的区别
1. go是一种过程式编程语言 c++是面向对象编程语言
2. go有垃圾回收机制 c++没有
- 链表
go 
声明空结点
```go
newNode := &ListNode{}
var node *ListNode = nil
```
hash
```go
m := map[type]type{}
```
# golang的优势
1. 语法简单
2. 更高的效率，接近c的运行效率
3. 第三方库丰富，拓展性强
4. 严格的依赖管理，强大的编译检查，严格的代码规范
5. 跨平台交叉编译，直接生成可执行二进制文件
6. 并发和异步执行，一个go关键字搞定，goroutine
7. 严格的语言规范

# GMP模型
https://juejin.cn/post/6844904034449489933
## 早期单进程操作系统两个问题
单一执行流程，计算机只能一个任务一个任务处理
问题：进程阻塞带来cpu浪费
## 宏观的执行多任务---多线程/多进程操作系统   解决了阻塞问题
轮巡调度  时间片  一个进程不能超过一个时间片 轮巡执行  并发执行  
新问题：频繁切换进程 切换成本 cpu时间浪费成本
node.js ?
并发方式：一个线程执行一个任务   会导致高消耗调度cpu
进程数量多 切换成本大 越浪费
进程占用内存  

## golang 协程调度
操作系统将一个线程分为用户态和内核态
协程被称为用户态线程
协程与线程多对多的关系  协程（co-routine）---> Goroutine

go早期使用协程队列 

## GMP模型
G -- goroutine协程
P -- processor处理器
M -- thread线程
![image.png](https://i.loli.net/2021/07/21/lYv2F3ndwuracL6.png)

调度器的设计策略

复用线程   利用并行  抢占  全局G队列
          GOMAXPROCS限定p的个数
          =CPU核数/2

M0 ：启动程序后的编号为0的主线程 在全局变量runtime.m0中 不需要在heap上分配  和进程绑定
     负责执行初始化操作和启动第一个G
    启动第一个G之后，M0就和其他的M一样了

G0 ：每次启动一个M都会创建一个gourtine 即G0
     G0仅用于调度G
     G0不指向任何可执行函数
     每个M都会有一个自己的G0
     在调度或系统调用时会使用M切换到G0来调度
     M0的G0会放在全局空间